<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <title>Hatt | Benedict Eastaugh</title>
    
    <link rel="stylesheet" href="../../css/main.css">
    
    <link rel="alternate" type="application/atom+xml" href="../../blog.atom" title="Extralogical">
    
    <meta name="viewport" content="width=device-width,
          minimum-scale=1.0">
    
</head><body>
    <header id="header">
        <div class="wrapper">
            <h1 id="site-title" class="block-a">
                <a href="../../">Benedict Eastaugh</a>
            </h1>
            
            <nav id="navigation" class="block-b">
                <li><a href="../../research.html">Research</a></li>
                <li><a href="../../teaching">Teaching</a></li>
                <li><a href="../../talks.html">Talks</a></li>
                <li><a href="../../files/cv.pdf">CV</a></li>
            </nav>
        </div>
    </header>
    
    <section class="wrapper">
        <main id="main">
            <article>
    <h1>Hatt</h1>
    
    <section class="content">
        <p><a href="https://github.com/beastaugh/hatt">Hatt</a> is a command-line program which prints truth tables for expressions in classical propositional logic, and a library allowing its parser, evaluator and truth table generator to be used in other programs.</p>
<p>It’s written in Haskell, and is available from <a href="http://hackage.haskell.org/package/hatt">Hackage</a>, so if you have the <code>cabal-install</code> program it’s very easy to install; from the terminal you can just run the following commands.</p>
<pre><code>$ cabal update
$ cabal install hatt</code></pre>
<p>Then you can use the <code>hatt</code> binary to evaluate expressions. Use the <code>--help</code> flag to see a list of available commands.</p>
<pre><code>$ hatt --evaluate=&quot;(A &lt;-&gt; (B | ~C))&quot; --pretty
A B C | (A ↔ (B ∨ ¬C))
----------------------
T T T | T
T T F | T
T F T | F
T F F | T
F T T | F
F T F | F
F F T | T
F F F | F</code></pre>
<p>The following are all valid expression forms which can be parsed by Hatt, where ϕ and ψ are metalinguistic variables standing in for any valid expression.</p>
<ul>
<li>Variables: <code>P</code>, <code>Q</code>, <code>a</code>, <code>b</code> etc.—basically anything in the character class <code>[a-zA-Z]</code></li>
<li>Negation: <code>~ϕ</code></li>
<li>Conjunction: <code>(ϕ &amp; ψ)</code></li>
<li>Disjunction: <code>(ϕ | ψ)</code></li>
<li>Conditional: <code>(ϕ -&gt; ψ)</code></li>
<li>Biconditional: <code>(ϕ &lt;-&gt; ψ)</code></li>
</ul>
<p>For top-level formulae where the primary connective is a binary one, parentheses are not required. For example, the expression <code>a | b</code> is valid and will be parsed correctly.</p>
    </section>
</article>

        </main>
    </section>
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body></html>
